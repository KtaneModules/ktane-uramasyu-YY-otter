using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using KModkit;
using System.Text.RegularExpressions;
using System;

public class UraMasyuScript : MonoBehaviour {

    public KMAudio audio;
    public KMBombInfo bomb;

    public KMSelectable[] buttons;
    public GameObject[] gridbuttons;

    public GameObject[] whiteCircles;
    public GameObject[] whiteCircleRings;
    public GameObject[] blackCircles;
    public GameObject[] largeButtons;

    public Material[] changeitems;

    private string[] dots = { "200000000010000012102100000100200000000110011200", "202002000000000000010021100202200000010001000000", "020000000020000000120000010010000000110001000202", "200010101000010110000020000000020020200000000102", "000100110100010010001020010100000100000101200000", "000102010000002002000002212001000000110021000000", "010000000101010110001202100100000000002001200002", "010000100101200002010000010020000000010020010010", "000000010100000011011000002110121001110000000210", "010000000000010100021002000110000000120101200010", "000000010001211000021210100000000110010200000010", "000000101010020021000000020200200100000001010200", "010010100210000100210002000001000000120200000012", "021000000010010102000001020010000000110011000000", "000000100001021201210002000000000100120001000000", "000002201000020020010010000101000000101200002100", "001000100101000000020020200002001002000001200010", "210002020000000000100100210001000110000000020002", "201000000001101010202000001002000000001200002100", "212200000000000000001100200100010100101001000010", "200000121101000000000100200201001002110000000000", "000020011000200000001101010010000001000002012000", "000100111000010010001100000001011002002100010010", "000002101100000101000200000010011110011000000200", "000002101100000000000201001002010000000100210002", "010010002100010001001010100100021100010101000010", "200002000000000200001020000000001000100100002002", "010002010200000000110010000000001201101001000002", "000000000020200000002000000010100020201000000002", "000010000101000000020010100210210000000000010002", "002000101001010010100000000000012020000101010000", "000012120001010010001002100000001010012001010000", "021200000010010000002102100010001100100000000020", "000200110000000001010000120210010000001001010012", "000010120100000000000102000202010000001001010002", "201000000001000020012020000000100010000000002012", "010000010011200010000000010110010102000000200010", "000010201000000001010002000000002010001010200010", "010000020000000020000001002200000000001001000100", "000100010101000001020000100010200100011210000100", "200000000111010001001000110010000000010200010002", "000102210000100010000002002101010010000001000200", "021000010101010011000100001202010100000000000002", "000000010101101020010010102100000200010000001200", "010010010000000120000000020020000000100100002012", "200000000101002110010002000000100010102000000002", "000000002010000002102000000000001000000010000200", "012010101000002000012020000010100000001100200200", "010020000000200100000001101001011100000000010010", "010000001101010000002000000100000200100101001200", "202200000000001110010000000101010000000100002002", "202000000011102000002010011010000001012100000010", "200012102100001000000110021001000000000200210002", "000000110000010120000200002000000212000001200010", "020012000100001000000000010200010000120010010010", "010010000000000002012101000000011110000001200010", "021000010001001010002000000000200020000002201000", "000200000001020000001201000000001010100110002000", "012000000000012120000100010010020010000100010012", "000010101000001010000002020000200100010100000010", "000102010000020100100200000010010200010001000110", "000010000000001010021010010212000001021001000000", "000000101101000100200100101200010010100000000020", "000100010000101002001010020010000100000000200002", "010010100020200000002010100000000100001000200012", "011000000002010021001010100000102110200000000112", "000000000010101010010201200000000000001100200000", "210000000000000110212000101210000000100101002000", "000020001000110010001000200010101010000010000000", "000000110000000010021211010000010002001001010000", "010000000110100210000000010021011000000011002000", "012000000011000000010100010010020200101000000002", "212000000011000120100200000010200200000101010000", "000202002100000000011110000000001020001001000000", "000000010101010100011000100000000110002000000002", "000010010000200011001000000002000000100012002000", "010000100020010000000020002000000010000010210200", "010010000010001020201000000000100001120201000000", "002200001001010001000000001110200000010201000002", "210000000100102002000002010000000010002001200000", "010010002020010000001001000100010010110100000200", "002000000011000000001121000000200110000210010100", "000000102000000010010000210100101110100000000020", "200000000101021010000102000000210100010100000002", "202000000011000010000000010100010020000000210120", "200000000100020012010202000100020000101001000010", "001000100001001010010001010002002100000000002102", "010200000110002000000012010000010011010001000000", "000002101000001010001020200000011000010000000102", "000002000000020200001000000002020012000100200000", "200010000000010102010102100000011010010100010010", "010000000101000020000010101110000000012002010000", "211000000002010100000100011001001100000200200010", "001000000011011100000000001002000000121100000002", "002000000011000000101100002200000000010200010000", "010020010000010100000001020000000000000111200000", "010000000011102000010200010010000010200000000110", "001000001011000010002000000001200000100200010000", "000000012210000000100002021000000002110000000000", "010010010010001010000000200100010100011001000002", "000000100000002020200020000000010000002000001000", "000002010000002000010100200000020000000001000200", "000000110000000200000020120200000000001000000000", "010002010000000002100002010000000020110000000000", "200002000000001100010100000100001010000000002010", "200210000001101000000100201010000000000002201000", "011000002110000000010100020000000010020000000000", "010002000000010100200010000000000002002000200010", "200000000101002000000010200000201010000000200000", "202002000000000010000000001002000000011200000110", "010000000001001110000000200100200100000101010000", "000000001002001100000001000100020002001100000000", "001002010000010100000010002002010100010100000000", "020000000000000100000100020010200100000002001000", "010000000001011100000001002000000010100200000010", "000000001100020000000000100101010000000200010020", "002110100000000100020001000010020000001100000000", "010000000110010110000010000001000000020020000000", "001200000001001000001000000000000020110000000102", "000000200100001010010000100201200000000001010000", "001200000001001000000010000000002002020000010010", "000100011001010000000020010000000010002001000200", "010202100000010000000100000100000000020010000010", "000002000000200100010000001020001000101000000002", "010000100110000000000200010000001020101000000010", "000010011000010100200000000200000010010000000110", "000100100101000000000200000010010000100000000202", "000000002000000010100000020201000000001010010010", "001000100101000110000000200000000010002110010000", "000100110000000002000000000211010000010001010000", "001000100010002010010000002000001002000000000010", "000000010020010000010000100101000000002001020000", "000002110100000000100200010002001100000000200002", "010010001010000010010100000000102000000000010010", "200000000001000000002200000000100010020100000000", "000002000020001000000000000000102001001100000010", "010020100000012000000000100100010000000011200000", "010000000101002010000010010100000102000010020000", "000002110000000200000020200000010020010100000000", "202010000000000100000002010010000100020100000010", "010000000102000100110010000000200101000100000000", "000002101000020000000100000001000000020201000000", "200000000001001200020000000011000000020010010000", "000200000001020000000020200000000000002000010000", "001000000000110021000000200000000101000100010000", "000202000000020000200001001000100210000000200200", "000010010210200000000001001100010000100010000200", "200002000000000100020010001021010000010100000000", "002010010000010100000001002000010000000001011000", "000002000000000102100200000000001000100200000000", "002000100010000000002020200020000000101000000000", "200002001000000100001001010100011010010000000110", "000010001000201200000010000110020000010000000102", "000010001000200100200010000100000000001000200202", "010000000000000110201010000100011000000011000000", "001000002000010010001000000000000020100000002010", "010000002001010000000000020010000000020000000020", "000010000020200000011000000000001000001011010000", "200000001000000000000021100200001000000100200000", "010002000100000100100010001010001021010000000000", "000010000000000110020010000201010000010101000000", "200000000010102000010000010000001011000000000010", "020010000001000000100100001001010002000000020010", "002100100000000000000020100100001000011100000002", "000200000000020001100000010100010010100010001000", "010010000010011000000020101000000000020000000010", "000000000100200001202100000001000000000200000020", "200000001110000000101100000001002020010000000000", "000210000000200000000002000110000000020100010000", "001000020001000010001000000000011010100010000200", "000000101002010000100110010000000000010011010000", "000200100010001000200002000002000000002000000002", "012002000000100010001000000100020000000000010020", "200002000100000010010000002000010100000100010002", "000000001100100020000000200000001200101000000000", "000000001002201000000101010000010110000000200010", "002000010000000010001000020000000010020100000010", "000010002000000010102001020010000100100000002000", "000002001000001010202100000110010010000000000000", "000010100020010000010000000010011010000000010010", "000000000001010110000000020001000100011010000010", "200000000101001000002020000000001010000110000000", "000010010200000010010100100001020000000001000200", "011000000010010101000000000201000000000010012000", "000002000200000001001010100000002020000000020000", "000002101000000020000000020000002000000010200000", "000200110000000010000000020201020100000000000100", "000000110200000001001000000010200000010201000000", "200000002020000000000000010002000000000201000000", "000000000100020101200000010100000000100100001000", "000010101000001000001020000000010020000102010000", "000000000010001000000200011000000000010020010000", "200000000010000001010000012020000002100000000200", "200000002010000000000002200100201000000000010000", "010010001010000000100110000100010020001000010000", "020002000000000100000010001010020010100000000000", "010010000200011000000010001010000000001010000010", "010002010000020010000000000020010100000101010000", "200000000020100200000000011000010001010100000002", "000000110200001000000010020020000000010100000000" };
    private string[] solutionH = { "1111101011000110011010110110100000011101", "1101100010010000011001011110011101011111", "0111100110101000110000000000100000010011", "1111101111001110011000000011101100000111", "1011100110000000111011110111100011011001", "0011111000110110001111010011000011010111", "1100110110001111001100000000100011011111", "1100100110110111101111110000001111011111", "0111100110000000000110111011000000010011", "1111111110111100111100111001100111011111", "1111111100111010110000000100001110111111", "1000001111011100000001100110001100011101", "1111100011000001101110100000000110011111", "0111100111001111001001100000000000010001", "1001100000011001101110011001100111011111", "0001111100011100010001000010010001110111", "1110101000001000111011011100110100011111", "1111101110001010100111000010000001001111", "1110101100011001101000011000000001100111", "1101100000010100111011110111100110010011", "1111101110000101000011100011110000010000", "1111011100111010111000000010100001111000", "1011100010001000111010100000111011111111", "1101100000010000110110100000000000101011", "1101100000010000110001111000010111011111", "1111110110000101001100111011100011010111", "1101101000011000111001000000100000011011", "1111111100100010000000001011000110010011", "1111100110110001100000000001101110000011", "1111101110000010111100011110011101011111", "1011100010001000100010000001101011011001", "1111101100000110111101010100001100011101", "0110100000000101011100011000010010011110", "1001100000000000000101100111011110011111", "1111101110001100011100011000000110011111", "1110100100101100011010000000000001011011", "1110111000110000101000111001110100011111", "0001111100010000001100011001110111111111", "1110101100001100100011011000010001000111", "1011100110000100110100100110001110011110", "1110101000000100000100100100011110011111", "0011111000010110001100110001000100011101", "0111100110001000100110011001100111011111", "0000111110011100000000110100111100011100", "1111111000101100000001110001000000011011", "1100100110101110001110010000000011011111", "1111111011100110011000110000100100011101", "1101100010101100011010000000100000011011", "1111000100110011010000010000010101111111", "1101110000000101011001110011000000011101", "1101100001100000010100110000101000011011", "1100100000001101011100011000100011001111", "1111100110100010011101100100000110011111", "1000100000001100101111000100110100011111", "0111100110100100100000011000000111111111", "1111111011100110011000100000000101011111", "0111100110100001100000000111100001111100", "1001100000011000110001001000000000011010", "1100110000001100011000100011001111011111", "1001101100011110001101100111101111011111", "1011100110011100110110000111011100000111", "1111101111011110111100011000000110011111", "1000101110111101111001101000000010010110", "0011111000011110111101111001110100011111", "1111100110110001100000010010000110011111", "1110010011001101000000001001111100000111", "1111101111011111110011000010100111011111", "1111101010100001100001100010100000011011", "1111001100001001001011011011110111111111", "1011100010010000110000001000110110011111", "1101001000011001000100110000001000011001", "1100100000010100000100000011010110010011", "1100100000001100110110000111010011011001", "0001111000100010000010101011100110011101", "0000111110111101110001000100001101011111", "1111111010110000110101111001000001111000", "1111100110110001111011010100000100011101", "1111101111011101110010001000000110011111", "1101110000001001010100000110011110011111", "1100100110001111001100010100000011011111", "1111110110000001001001001000000000110011", "1100100000010000111000101110001110011110", "1111100110000001101011001000000010011110", "1100100110011110011101000111101111011111", "1100100000001000101000111001100100011110", "1100100110011110001100000011000110010011", "1110101100011001101011011110010001000111", "1110100000110100001111001110001101011111", "1001101100011110111011100111011100000111", "1001100000011000110000011011110011011001", "1111101000001110011101010111001111011111", "1100100110011100010000000100101101111100", "1110000011111101011000010000010101111111", "1110101000000000001000011001010111011111", "1100100000010000111011011000001101111111", "1111011100110010010001110001000100011101", "1100100000001101110111000001001100100111", "1110101100011001101000010110010001111111", "1111111011100000101101100000110000010000", "1111111011100110100011110111101110000011", "1100100000001101111001000000000011001111", "0101100010101101111011110011000000010011", "1010000000000110011001100110000001000111", "1111111000110110101100000001100000010001", "1101101010011101111000110000110001100111", "1101101000011001111011100000100001111100", "1110111000000001100001100000000111011111", "1111100010110011101100100000110011111111", "1100100110001100000011000111000001011111", "1101100010001000101000011000000001110111", "1110111000100000101011110111100011011001", "1000001111011100011000111011110111010001", "0111100100000001001100111111101111011111", "0111100010000000000001100111100001111100", "1111110100000001000011001100000110111111", "1000101110011100001001000110011110011110", "1011100011010010110000000011100111010001", "1100010111001111001101010000000111011111", "1110101000000100001000100001100000010111", "0000111110011110000101100110001101011111", "1110101000000000000000010001110111111111", "1011100010001000111011010000001100011101", "1101101000000100111001110000010111111111", "1111100100110011110001110011110110010011", "1110100000000000110000000011100110010011", "0001111100111101111001101000000010110111", "1011100110011100110100000000010100011011", "1111111010100000100001100000010111111111", "1110100000000000001011010000001100011101", "1011100000010110110101100110001101011111", "1110000011101110000110110011110111111111", "0000011110111001100100000100100011001111", "1001100000000000110011011100010101011111", "1111101111011111111011110001100001011011", "1111100010000011101110010001000111011111", "1111101110011001100110011001100111011111", "1111000000110011001000000000000100011101", "1111111110110001000000110001110011101111", "1001100000011000011011000111101111000001", "1101100010001100111100111001100111011111", "1100000111011100000010000111100011111000", "1001101100011110011100100000000110011111", "1101101000011000111000000000010111111111", "1001100000011001111011000000000011011111", "1110001011001101000011000001100011111000", "1001100000011001110011101011000100111011", "1111111011110010001001110001000100011101", "1111101000001110111101110000000011010111", "1011100011000010101010110000001010011101", "1111101000001110110011000100000101111111", "1100100000000000011011110100000111011111", "1111101100010000000011001111001100100111", "1001101100111011000000000011011100000111", "1001101100111101100000110001000000011011", "1111100010000001110010110000100100011101", "0111100110000001000001000001100000010111", "1111110110000011011101111000100110011110", "1111100110110001110000010011100110011101", "1111101110100001011000011000000100011100", "1111111110111100111101111011100000010001", "1111101000001110111101100000000000010011", "1100100000001101101111001011000111011111", "0111100000100000011010010000110011101111", "1011100010001000111000110100100000001011", "1001100000011000001111000110110001111100", "1111110111000001011001100000100111111111", "1100000111111001100000000010010110011110", "1101000000000000000110100001100000001001", "0001100000111000111100111001100111011111", "1110101100001000001000010000000100011101", "1010000011000100100011000000001100011101", "1110101000100101101101011100001100011111", "1101100010000001000000110011011110011110", "1111100110100000000110111111101111011111", "1000101110011101010011000011000111011111", "1000001111111001000000001000000110111111", "1011100010001000110001100000000111011111", "1111111011100110011001100010000001010111", "0011100000000111100101000001000111011111", "1111100110110001111010111000111010011111", "1111101010000000010001100010010001110111", "1110100000011000011000010000000100011101", "1111111101000001100100100011000000010011", "1110000011111101111001100010010000011010", "1111101100010000001100000101100000001110", "1011100000001100000001110001100000011001", "1001100001000000000101100011100011010111", "1000000011000000110100100110011110011111", "1111100110000000100100011000000110011111", "1011100110011101101111000000000000011100", "1111101111011110111010000111100011111000", "1111101011000000001100010101001111011111", "1100000011100100000000110100110000011100", "1111100111000000011111110111000001011111", "1111101111011110011110111001101000011001", "0111100100100000101101111011110000010000", "1111101011000000001100011001000111111111", "1111111110011000010010110111101111011111", "1100000110011001000011101111101111011111", "1011100011000000101101110000000011010111" };
    private string[] solutionV = { "111101101110000110100010001100010111011111", "111110100110001101010100011001100101111011", "001111111011110100000001001101111001111111", "111111001111000010001000000000011001011111", "111101111100001000001000000001101011111111", "010011100000111011001001010000001101101111", "100111101100001011110000110010000101101111", "110100100000001010000001000010001101101111", "000011111110110111000000001101100001110111", "101111100011100000100000000001000101110111", "101110100011000000000010111000111101100001", "111110110110000000010000011100111110111111", "111011100001100001000011011000000001001111", "000111111101110100000000100000011111011111", "111011111001100001100110100000000101110111", "011111100110110001011100111000111001111101", "111101101100100100110110010011100001111011", "111100001100110010100001111001011101101111", "111000001000000001111101011011100001111001", "111101100100011100000110000100101001111111", "111011101100110000000001100001000001111100", "101111100011000000011010001011011000011110", "111100111101101100110010010001100001111101", "111100000101111100111111011100011101110001", "111111100101101100000111000000000101111011", "100111101100110111001001000001000101110111", "111111101010001000111110001100011001111111", "101111100111010000000011110100110001100111", "110111000000000101100000000101111001111111", "111110101100000000010000011001000101101011", "111100111101101101101010000001111011111111", "111110101101000000110010011100001111101111", "000111111100000001110110011011000111110100", "111110111110000000000111101000011001110011", "111111101111100010000000011001000001110111", "110011100110000101111100000111011101111111", "101111100011100101010111000011100001111011", "011111100111100011100100100000000001110101", "111100001100000010111100011011000101111011", "111110111100001000100001011001011111110000", "111110101111000111000110011011011001110011", "011111100111101011010001001100001111101111", "000011111101100101100001100001100101110111", "011110100111000000110000001110110001111100", "101111100110000100011000001100110001111111", "110011100110001011110000100010001101101111", "101111100111100110110010001100010111011111", "110011100110001101111100001101011001111111", "110111100011100101110011011011001000011101", "100111101101001110000110001100101111111111", "110000100111101110111111001101101001001111", "111000000011111101110000010011000101110111", "110001100110100110000000011001000001101111", "111101111100100010110000110011000001110011", "001111111011100110000001100001000001111001", "101111100111100110110010011000011101011111", "001001111000000110000000000101111001111110", "111111111010000000111110111100001111111000", "100000101111001101000000010011011101111111", "111110110110000000000100100000000101101111", "111101011010001000001000110001011001110011", "111111101011100000000000011000000001010111", "110111110001110000001000011010101111111000", "011111100101101000010000000000000001101011", "110111100000100101100000011001110001111111", "100111001100000011101100000000110000111011", "111011101000100000100000110000000101011111", "110111101001000110011011101101111001111111", "111011101100100011000010100011100000000101", "111111111011101100000011001001110001111011", "111000101011101000111110000011101110001111", "111111100111011100000001110111011001110011", "111101100010001100001000110011011011110011", "010011100110100111000111100100110111100111", "010110100001000000110000111010111101111111", "101111100010000100011011001001100001110110", "110101100000100100110000011101101111111111", "111011101001100000000000111000110001000111", "100110101100001101100110111000011001110011", "111001100011001011110000100010001101101111", "100111101101110111000000111101101101111001", "111110100100001100100000011011101111111000", "111011100000000110110000111001101111111000", "111110100110001001000000000010000101101111", "111111100011101101010001000011100111111000", "111111100111011000000000110110000001101111", "111010001000000001011101011011100101111011", "110010100000000011010110111011001101110111", "111101010100000000001100010000011001100011", "111111111011000000001110100000000011111011", "111110101110000101000000010000001101101111", "111110100111001001110000110110111001111110", "110111100011100001110100011000101000111101", "111111101111100111100111010011100101111011", "111100100100001100110000011011100001111001", "101111100001100010010011001111001110011111", "111011000000001100101000110011011101110001", "111001101000000001100101011011101001111101", "101111100101110110000011010000000001001100", "101101000100000110000010000100001001011111", "111000000001111100110000000011011101111111", "001011111000111100000100001101010001111111", "111110011110001110011110011000011100011111", "101111100011110101100001000000000111101111", "111000001000001000111100001001010001111101", "111011101000001000000110010100011001111110", "100111100001100110000111100011111101111111", "110111100000000010110011010001000001101101", "111101100000001011000000001010111101111111", "111111100011111101111101011001100001111001", "101101100100000110001111000011101011111111", "111111110111010001000000000000100010111011", "000110111100000111000011000000000101110111", "000001111110000000000011100101111001111110", "100101101100100111000011111000001101111001", "111110110110000000100000111010100111111100", "111111111011011100000011000000111011011111", "100111101101101011000000100000001100101111", "111111101111110111011110100011011001111111", "011110100110000000010000011010011101101111", "111111101111100111100111100011110001111101", "111100111100001100110010011101101111111111", "111111101101101000000110000000101001111101", "110111100001010100000011000100110001100011", "111111100011010000000111000111111001111111", "010111100001110000001100011000101101111001", "111111111011101000001000111101011001110011", "101111100101100110000011100001111001111101", "111100100000000000110111011111101111111111", "111110111010001100010001011000011101101111", "110011100110100011000100000000010000101101", "010110000000110001110001110001100100001111", "111101111100100000110111011000000101111011", "111011101000000000011000000100010101011111", "111011100001100001100011010001001101101111", "111011101001100001100001100001100101110111", "110111100011100011110000111111011110011111", "101000000011110011010000000001110001111101", "111101011000000001000110000000011011111111", "111111100011101100100100000001000101110111", "111101100110001000001000000000111000111110", "111111110111100001000100011000000001101111", "111111101011101000000110000000011001111101", "111011111000000000110110000000011101111111", "111011101100000100101100000000111000111110", "111011111000100000001110101100001101111001", "101111100001100100010011001100101111011111", "111111101101110100001000000000001101101111", "111100111101101110110011000100101111011111", "111101101100100100110000111000000001100001", "111101100000101110000000000011101101111111", "111101001000000011001011110000001101111001", "110111010011000000001101110000111001100011", "110111110000000001011100001100110001111111", "111011100001100000110011001101110111111111", "000111111101110111011000000001111001111111", "100111101101100110000000001001000111101000", "110111100000100100000000100101110111111111", "110111101011100001110000011101100001111000", "101111100010110000000000000001000111110111", "111111101101110100000000011100000001101111", "111011100000101101000000110011001101110111", "001100011001110001110000010000010001111101", "111110011100111100111010001101101001111111", "111101111000000000100110110100000001110010", "100111101101100110000000010000011001000001", "110111100000101001100001111000000110111100", "111100000001111111011111100011100110001111", "001111100011100000100110000000000101110111", "111111101111100011110101011111101111111111", "111100111100001110110101111100111110111111", "110110101001000110110110100011000001110111", "111000100011001111000100001001110111111100", "110010100110000111000000000001100101110111", "111011110100100001000000110010111101111111", "110111110011100000000001111000001100111001", "111111111101101100000010100001111101111111", "101111100110110110011010011000011101011111", "000111100001101110100001110000011101101111", "110100100001100100110000001001100001111011", "111111101110110110011011011001111001111101", "111111100111100001110110011111101111111111", "100111100000110001000011101101100001001111", "110111100001000000011100011100100110111100", "111110001000110011100011000000000111110000", "111111111110001100011000000000110111111111", "111111111110110000001111100001100101001111", "111110111100000000100011011000011000110011", "111111100011100110000000011001100001110111", "111011111000001001000000111101000001110000", "111101101010000000001000000000011001011110", "111110101111000111100011010000001101001111", "110001100111001111000010001100110000111100", "111101100000000110000000001000001101001111", "111100101001100001011000000000000111010111", "001111111010110110000011000000000001110100", "111111101111100111100011010000000001001001", "100010100110000001000001000001110101111111", "111010100100001000000001100001110100000111", "111111111101111110001011000000001101001111" };
    private int usedPuzzle = -1;
    private bool changesMasyu = false;

    private string horizSelection = "0000000000000000000000000000000000000000";
    private string vertSelection = "000000000000000000000000000000000000000000";

    private int sol = 0;

    private Coroutine runner;
    private double timeHeld;

    static int moduleIdCounter = 1;
    int moduleId;
    private bool moduleSolved;


    private char whiteDotNum;
    private char blackDotNum;
    private string oneMeansColor;
    private string twoMeansColor;
    private int submitbuttonIndex;
    private int clearbuttonIndex;
    //index 82=black, 83=white

    UraMasyuSettings Settings = new UraMasyuSettings();

    #pragma warning disable 414
    private static Dictionary<string, object>[] TweaksEditorSettings = new Dictionary<string, object>[]
    {
        new Dictionary<string, object>
        {
            {"Filename", "UraMasyu.json"},
            {"Name", "UraMasyu"},
            {"Listings", new List<Dictionary<string, object>>
                {
                    new Dictionary<string, object>
                    {
                        {"Key", "shouldSwapSubmitForClear"},
                        {"Text", "Masyu swaps the locations of the Submit and Clear button (easy mode)"}
                    },
                    new Dictionary<string, object>
                    {
                        {"Key", "shouldAppearOnlyUraMasyu"},
                        {"Text", "Masyu does not appear (easy mode)"}
                    }
                }
            }
        }
    };
    #pragma warning restore 414

    private class UraMasyuSettings
    {
        public bool shouldSwapSubmitForClear = false;
        public bool shouldAppearOnlyUraMasyu = false;
    }

    void Awake()
    {
        moduleId = moduleIdCounter++;
        moduleSolved = false;
        foreach(KMSelectable obj in buttons){
            KMSelectable pressed = obj;
            pressed.OnInteract += delegate () { PressButton(pressed); return false; };
            pressed.OnInteractEnded += delegate () { ReleaseButton(pressed); };
        }

        var modConfig = new ModConfig<UraMasyuSettings>("UraMasyu");
        Settings = modConfig.read();

        bool isForcedToSwapByMission = false, isForcedToAppearOnlyByMission = false;
        var missionDesc = KTMissionGetter.Mission.Description;
        if (missionDesc != null)
        {
            var optionsRegex = new Regex(@"\[UraMasyu\]\s*(true|false|default)(\s*,\s*(true|false|default)|)");
            var match = optionsRegex.Match(missionDesc);
            if (match.Success)
            {
                string[] options = Regex.Replace(match.Value, @"\[UraMasyu\]|\s", "").Split(',');
                
                //shouldSwapSubmitForClear
                switch(options[0]){
                    case "true":
                        Settings.shouldSwapSubmitForClear = true;
                        Debug.LogFormat("[UraMasyu #{0}] Mission forced this to swap Submit for Clear when Masyu appears.", moduleId);
                        isForcedToSwapByMission = true;
                    break;

                    case "false":
                        Settings.shouldSwapSubmitForClear = false;
                        Debug.LogFormat("[UraMasyu #{0}] Mission forced this not to swap Submit for Clear when Masyu appears.", moduleId);
                    break;

                    default:
                    break;
                }
                //shouldAppearOnlyUraMasyu
                if(options.Length >= 2)
                {
                    switch(options[1]){
                        case "true":
                            Settings.shouldAppearOnlyUraMasyu = true;
                            Debug.LogFormat("[UraMasyu #{0}] Mission forced Masyu to not be able to appear in this.", moduleId);
                            isForcedToAppearOnlyByMission = true;
                        break;

                        case "false":
                            Settings.shouldAppearOnlyUraMasyu = false;
                            Debug.LogFormat("[UraMasyu #{0}] Mission forced Masyu to be able to appear in this.", moduleId);
                        break;

                        default:
                        break;
                    }
                }
            }
        }

        if(Settings.shouldSwapSubmitForClear && !isForcedToSwapByMission){
            Debug.LogFormat("[UraMasyu #{0}] Setting swapped Submit for Clear when Masyu appears.", moduleId);
        }
        if(Settings.shouldAppearOnlyUraMasyu && !isForcedToAppearOnlyByMission){
            Debug.LogFormat("[UraMasyu #{0}] Setting forced Masyu to not be able to appear in this.", moduleId);
        }
    }

    void Start() {
        clearPuzzleInit();
        clearPuzzleMain();
        generatePuzzle();
        swapSubmitForClear();
        //fillSolution(usedPuzzle);
    }

    void PressButton(KMSelectable pressed)
    {
        if(moduleSolved != true)
        {
            audio.PlayGameSoundAtTransform(KMSoundOverride.SoundEffect.ButtonPress, pressed.transform);
            if (pressed == buttons[submitbuttonIndex])
            {
                //Submit button
                pressed.AddInteractionPunch(0.25f);
                if (horizSelection.Equals(solutionH[usedPuzzle]) && vertSelection.Equals(solutionV[usedPuzzle]))
                {
                    moduleSolved = true;
                    success();
                    GetComponent<KMBombModule>().HandlePass();
                }
                else
                {
                    StartCoroutine(wrong());
                    GetComponent<KMBombModule>().HandleStrike();
                }
            }
            else if (pressed == buttons[clearbuttonIndex])
            {
                //Clear button
                pressed.AddInteractionPunch(0.25f);
                runner = StartCoroutine(timer());
            }
            else
            {
                //If the grid button pressed was a vertical one then toggle it
                if (pressed.name.Contains("v"))
                {
                    int realind = Array.IndexOf(buttons, pressed) - 40;
                    if (vertSelection.ElementAt(realind).Equals('0'))
                    {
                        gridbuttons[Array.IndexOf(buttons, pressed)].GetComponent<Renderer>().enabled = true;
                        vertSelection = vertSelection.Insert(realind, "1");
                        vertSelection = vertSelection.Remove(realind + 1, 1);
                    }
                    else
                    {
                        gridbuttons[Array.IndexOf(buttons, pressed)].GetComponent<Renderer>().enabled = false;
                        vertSelection = vertSelection.Insert(realind, "0");
                        vertSelection = vertSelection.Remove(realind + 1, 1);
                    }
                }
                //If the grid button pressed was a horizontal one then toggle it
                else
                {
                    if (horizSelection.ElementAt(Array.IndexOf(buttons, pressed)).Equals('0'))
                    {
                        gridbuttons[Array.IndexOf(buttons, pressed)].GetComponent<Renderer>().enabled = true;
                        horizSelection = horizSelection.Insert(Array.IndexOf(buttons, pressed), "1");
                        horizSelection = horizSelection.Remove(Array.IndexOf(buttons, pressed) + 1, 1);
                    }
                    else
                    {
                        gridbuttons[Array.IndexOf(buttons, pressed)].GetComponent<Renderer>().enabled = false;
                        horizSelection = horizSelection.Insert(Array.IndexOf(buttons, pressed), "0");
                        horizSelection = horizSelection.Remove(Array.IndexOf(buttons, pressed) + 1, 1);
                    }
                }
            }
        }
    }

    void ReleaseButton(KMSelectable pressed)
    {
        if (moduleSolved != true)
        {
            if (pressed == buttons[clearbuttonIndex])
            {
                audio.PlayGameSoundAtTransform(KMSoundOverride.SoundEffect.ButtonRelease, pressed.transform);
                StopCoroutine(runner);
            }
        }
    }

    private void success()
    {
        for (int i = 0; i < gridbuttons.Length; i++)
        {
            if (gridbuttons[i].GetComponent<Renderer>().enabled)
            {
                gridbuttons[i].GetComponent<Renderer>().material = changeitems[2];
            }
        }
    }

    private IEnumerator wrong()
    {
        for (int i = 0; i < gridbuttons.Length; i++)
        {
            if (gridbuttons[i].GetComponent<Renderer>().enabled)
            {
                gridbuttons[i].GetComponent<Renderer>().material = changeitems[3];
            }
        }
        yield return new WaitForSeconds(1.0f);
        for (int i = 0; i < gridbuttons.Length; i++)
        {
            if (gridbuttons[i].GetComponent<Renderer>().enabled)
            {
                gridbuttons[i].GetComponent<Renderer>().material = changeitems[1];
            }
        }
        StopCoroutine("wrong");
    }

    //Debug method that fills the grid with the specified solution path (indexed starting from 0)
    private void fillSolution(int target)
    {
        for(int i = 0; i < solutionH[target].Length; i++)
        {
            if (solutionH[target].ElementAt(i).Equals('1'))
            {
                gridbuttons[i].GetComponent<Renderer>().enabled = true;
            }
        }
        for (int i = 0; i < solutionV[target].Length; i++)
        {
            if (solutionV[target].ElementAt(i).Equals('1'))
            {
                gridbuttons[i+40].GetComponent<Renderer>().enabled = true;
            }
        }
        horizSelection = solutionH[usedPuzzle];
        vertSelection = solutionV[usedPuzzle];
    }

    private void clearPuzzleInit()
    {
        //clears the puzzle of all already enabled dots
        for (int i = 0; i < whiteCircles.Length; i++)
        {
            whiteCircles[i].GetComponent<Renderer>().enabled = false;
        }
        for (int i = 0; i < whiteCircleRings.Length; i++)
        {
            whiteCircleRings[i].GetComponent<Renderer>().enabled = false;
        }
        for (int i = 0; i < blackCircles.Length; i++)
        {
            blackCircles[i].GetComponent<Renderer>().enabled = false;
        }
    }

    private IEnumerator timer()
    {
        timeHeld = 2;
        while (timeHeld < 3)
        {
            yield return new WaitForSeconds(0.01f);
            timeHeld += 0.01;
        }
        clearPuzzleMain();
        StopCoroutine(runner);
    }

    private void clearPuzzleMain()
    {
        //clears the puzzle of all already enabled paths
        for (int i = 0; i < gridbuttons.Length; i++)
        {
            gridbuttons[i].GetComponent<Renderer>().enabled = false;
        }
        horizSelection = "0000000000000000000000000000000000000000";
        vertSelection = "000000000000000000000000000000000000000000";
    }

    private void generatePuzzle()
    {
        //pick puzzle to use at random
        TimeSpan currentTime = DateTime.Now.TimeOfDay;
        UnityEngine.Random.InitState((int)(currentTime.Ticks % uint.MaxValue) + moduleId);

        usedPuzzle = UnityEngine.Random.Range(0, dots.Length);
        if(Settings.shouldAppearOnlyUraMasyu)
        {
            changesMasyu = false;
        }
        else
        {
            changesMasyu = UnityEngine.Random.Range(0, 2) == 1 ? true : false;
        }
        
        if(changesMasyu)
        {
            Debug.LogFormat("[UraMasyu #{0}] Masyu is chosen", moduleId);
            whiteDotNum = '1';
            blackDotNum = '2';
            oneMeansColor = "white";
            twoMeansColor = "black";
            submitbuttonIndex = 82;
            clearbuttonIndex = 83;
        }
        else
        {
            Debug.LogFormat("[UraMasyu #{0}] UraMasyu is chosen", moduleId);
            whiteDotNum = '2';
            blackDotNum = '1';
            oneMeansColor = "black";
            twoMeansColor = "white";
            submitbuttonIndex = 83;
            clearbuttonIndex = 82;
        }

        //automatically fill in the dots depending on the picked puzzle
        for (int i = 0; i < dots[usedPuzzle].Length; i++)
        {
            if (dots[usedPuzzle].ElementAt(i).Equals(whiteDotNum))
            {
                whiteCircles[i].GetComponent<Renderer>().enabled = true;
                whiteCircleRings[i].GetComponent<Renderer>().enabled = true;
            }
            else if (dots[usedPuzzle].ElementAt(i).Equals(blackDotNum))
            {
                blackCircles[i].GetComponent<Renderer>().enabled = true;
            }
        }
        Debug.LogFormat("[UraMasyu #{0}] The dots/circles are in the following pattern, where 0=blank,1={1},2={2}...", moduleId, oneMeansColor, twoMeansColor);
        Debug.LogFormat("[UraMasyu #{0}] {1}", moduleId, dots[usedPuzzle].Substring(0, 6));
        Debug.LogFormat("[UraMasyu #{0}] {1}", moduleId, dots[usedPuzzle].Substring(6, 6));
        Debug.LogFormat("[UraMasyu #{0}] {1}", moduleId, dots[usedPuzzle].Substring(12, 6));
        Debug.LogFormat("[UraMasyu #{0}] {1}", moduleId, dots[usedPuzzle].Substring(18, 6));
        Debug.LogFormat("[UraMasyu #{0}] {1}", moduleId, dots[usedPuzzle].Substring(24, 6));
        Debug.LogFormat("[UraMasyu #{0}] {1}", moduleId, dots[usedPuzzle].Substring(30, 6));
        Debug.LogFormat("[UraMasyu #{0}] {1}", moduleId, dots[usedPuzzle].Substring(36, 6));
        Debug.LogFormat("[UraMasyu #{0}] {1}", moduleId, dots[usedPuzzle].Substring(42, 6));
        Debug.LogFormat("[UraMasyu #{0}] The horizontal connections pattern should be in this order, where 0=blank connection and 1=filled connection", moduleId);
        Debug.LogFormat("[UraMasyu #{0}] (This should be read as the first character being the tl horizontal connector, and the last being the br horizontal connector with all inbetween being read in reading order)", moduleId);
        Debug.LogFormat("[UraMasyu #{0}] {1}", moduleId, solutionH[usedPuzzle]);
        Debug.LogFormat("[UraMasyu #{0}] The vertical connections pattern should be in this order, where 0=blank connection and 1=filled connection", moduleId);
        Debug.LogFormat("[UraMasyu #{0}] (This should be read as the first character being the tl vertical connector, and the last being the br vertical connector with all inbetween being read from top to bottom of each column from left to right)", moduleId);
        Debug.LogFormat("[UraMasyu #{0}] {1}", moduleId, solutionV[usedPuzzle]);
    }

    private void swapSubmitForClear()
    {
        if (Settings.shouldSwapSubmitForClear && changesMasyu)
        {
            largeButtons[0].transform.localPosition = new Vector3(0.05f, 0.0f, 0.004f);
            largeButtons[1].transform.localPosition = new Vector3(0.05f, 0.0f, -0.0415f);
            largeButtons[2].transform.localPosition = new Vector3(0.05f, 0.0f, -0.0415f);
        }
        else
        {
            largeButtons[0].transform.localPosition = new Vector3(0.05f, 0.0f, -0.0415f);
            largeButtons[1].transform.localPosition = new Vector3(0.05f, 0.0f, 0.004f);
            largeButtons[2].transform.localPosition = new Vector3(0.05f, 0.0f, 0.004f);
        }
    }

    //twitch plays
    #pragma warning disable 414
    private readonly string TwitchHelpMessage = "!{0} a1 b1;d4 d5 [Toggles the edges between the sets of two specified adjacent cells] | !{0} white [Presses the white button] | !{0} black [Presses the black button] \nAdditional commands are available. Use !{0} h/horizontal/v/vertical help to learn more about the horizonal and vertical commands. Use !{0} d/draw/t/trace help to learn more about draw and trace commands.";
    #pragma warning restore 414

    IEnumerator ProcessTwitchCommand(string command)
    {
        if (Regex.IsMatch(command, @"^\s*black\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant))
        {
            yield return null;
            buttons[82].OnInteract();
            if(clearbuttonIndex == 82)
            {
                while (timeHeld < 3) { yield return new WaitForSeconds(0.1f); }
                buttons[82].OnInteractEnded();
            }
            yield break;
        }
        if (Regex.IsMatch(command, @"^\s*white\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant))
        {
            yield return null;
            buttons[83].OnInteract();
            if(clearbuttonIndex == 83)
            {
                while (timeHeld < 3) { yield return new WaitForSeconds(0.1f); }
                buttons[83].OnInteractEnded();
            }
            yield break;
        }
        string[] parameters2 = command.Split(' ');
        if (Regex.IsMatch(parameters2[0], @"^\s*h\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant) || Regex.IsMatch(parameters2[0], @"^\s*horizontal\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant))
        {
            yield return null;
            if (parameters2.Length == 2)
            {
                if (parameters2[1].EqualsIgnoreCase("help"))
                {
                    yield return "sendtochat !{1} h/horizontal 101100011 [Toggles the horizontal paths in reading order starting from the TL where 0=nopath & 1=path]";
                    yield break;
                }
                else if (parameters2[1].Length <= 40)
                {
                    for (int i = 0; i < parameters2[1].Length; i++)
                    {
                        if (!parameters2[1].ElementAt(i).Equals('0') && !parameters2[1].ElementAt(i).Equals('1'))
                        {
                            yield return "sendtochaterror The specified horizontal path character '" + parameters2[1].ElementAt(i) + "' is invalid!";
                            yield break;
                        }
                    }
                    for (int i = 0; i < parameters2[1].Length; i++)
                    {
                        if (parameters2[1].ElementAt(i).Equals('1') && horizSelection.ElementAt(i).Equals('0'))
                        {
                            buttons[i].OnInteract();
                        }else if (parameters2[1].ElementAt(i).Equals('0') && horizSelection.ElementAt(i).Equals('1'))
                        {
                            buttons[i].OnInteract();
                        }
                        yield return new WaitForSeconds(0.1f);
                    }
                    yield break;
                }
                else
                {
                    yield return "sendtochaterror Please make the length of the horizontal path string 40 or less characters!";
                    yield break;
                }
            }
            else if(parameters2.Length == 1)
            {
                yield return "sendtochaterror Please specify the horizontal path(s) you wish to toggle!";
                yield break;
            }
            else
            {
                yield return "sendtochaterror Too many parameters!";
                yield break;
            }
        }
        if (Regex.IsMatch(parameters2[0], @"^\s*v\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant) || Regex.IsMatch(parameters2[0], @"^\s*vertical\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant))
        {
            yield return null;
            if (parameters2.Length == 2)
            {
                if (parameters2[1].EqualsIgnoreCase("help"))
                {
                    yield return "sendtochat !{1} v/vertical 101100011 [Toggles the vertical paths in column order (top to bottom of each column from left to right) starting from the TL where 0=nopath & 1=path]";
                    yield break;
                }
                else if(parameters2[1].Length <= 42)
                {
                    for (int i = 0; i < parameters2[1].Length; i++)
                    {
                        if (!parameters2[1].ElementAt(i).Equals('0') && !parameters2[1].ElementAt(i).Equals('1'))
                        {
                            yield return "sendtochaterror The specified vertical path character '" + parameters2[1].ElementAt(i) + "' is invalid!";
                            yield break;
                        }
                    }
                    for (int i = 0; i < parameters2[1].Length; i++)
                    {
                        if (parameters2[1].ElementAt(i).Equals('1') && vertSelection.ElementAt(i).Equals('0'))
                        {
                            buttons[i+40].OnInteract();
                        }
                        else if (parameters2[1].ElementAt(i).Equals('0') && vertSelection.ElementAt(i).Equals('1'))
                        {
                            buttons[i+40].OnInteract();
                        }
                        yield return new WaitForSeconds(0.1f);
                    }
                    yield break;
                }
                else
                {
                    yield return "sendtochaterror Please make the length of the vertical path string 42 or less characters!";
                    yield break;
                }
            }
            else if (parameters2.Length == 1)
            {
                yield return "sendtochaterror Please specify the vertical path(s) you wish to toggle!";
                yield break;
            }
            else
            {
                yield return "sendtochaterror Too many parameters!";
                yield break;
            }
        }
        if (Regex.IsMatch(command, @"^\s*((d|draw)(\s+help|(\s+[a-f][1-8](\s+(\s*[uldr])*)?)+))|((t|trace)(\s+help|(\s+[a-f][1-8]\s+(\s*[uldr])+)+))\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant))
        {
            command = Regex.Replace(command ,@"(\s\s+)|([uldr](?!(r?a)|p|[1-8]|\s))", "$2 ", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant).ToLowerInvariant();
            var parameters3 = command.Split(new[] {' '}, StringSplitOptions.RemoveEmptyEntries);
            int inputMode = 0;
            if (Regex.IsMatch(parameters3[0], @"^\s*(d|draw)\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant))
                inputMode = 1;
            else if (Regex.IsMatch(parameters3[0], @"^\s*(t|trace)\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant))
                inputMode = 2;
            if (parameters3.Length == 2)
            {
                if (Regex.IsMatch(parameters3[1], @"^\s*help\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant))
                {
                    switch (inputMode)
                    {
                        case 1:
                            yield return "sendtochat !{1} d/draw a1 b1 b3 c3 d dr r e5 a5 [Clears the screen and draws a single continuous line segment connecting between each adjacent point or in specified cardinal directions. The entire string must be a valid path and cannot be started with cardinal directions. At least 2 coordinates are expected. Separate each coordinate with spaces]";
                            break;
                        case 2:
                            yield return "sendtochat !{1} t/trace a4 r u dlr c3 l [Traces path starting from the specified coordinates towards specified cardinal directions. The first arguments must be coordinate followed by cardinal directions. The command must end with cardinal direction. Separate each argument with spaces]";
                            break;
                    }
                }
                yield break;
            }
            //Limits the length of command
            if (parameters3.Length < 3 || parameters3.Length > 50)
                yield break;
            string directionalMovement = "udlr";
            bool[] isBreak = new bool[parameters3.Length - 1];
            string currentPosition = parameters3[1];
            isBreak[0] = true;

            for (int i = 1; i < parameters3.Length - 1; i++)
            {
                //Initial Regex.IsMatch requires that u d l r must be preceeded by coordinates somewhere in the string. Since this section of the code replace the directions with coordinate,
                //it therefore always expect the first parameters of the pair to have length of two.
                if (parameters3[i].Length != 2)
                    yield break;
                bool isTwoCharacters = parameters3[i + 1].Length == 2;
                //Ternary operator to prevent index out of range exception
                if (isTwoCharacters ? (inputMode == 1 ? ((parameters3[i][0] == parameters3[i + 1][0]) || (parameters3[i][1] == parameters3[i + 1][1])) : true) : false)
                {
                    isBreak[i] = true;
                    currentPosition = parameters3[i + 1];
                    continue;
                }
                else if (!isTwoCharacters && directionalMovement.Contains(parameters3[i + 1]))
                {
                    var currentPositionInArray = currentPosition.ToCharArray();
                    if (parameters3[i + 1] == "r")
                        currentPositionInArray[0] += currentPositionInArray[0] != 'f' ? (char) 1 : (char) 0;
                    else if (parameters3[i + 1] == "l")
                        currentPositionInArray[0] -= currentPositionInArray[0] != 'a' ? (char) 1 : (char) 0;
                    else if (parameters3[i + 1] == "u")
                        currentPositionInArray[1] -= currentPositionInArray[1] != '1' ? (char) 1 : (char) 0;
                    else if (parameters3[i + 1] == "d" && currentPositionInArray[1] != '8')
                        currentPositionInArray[1] += currentPositionInArray[1] != '8' ? (char) 1 : (char) 0;
                    currentPosition = new string(currentPositionInArray);
                    parameters3[i + 1] = currentPosition;
                    continue;
                }
                yield break;
            }
            yield return null;
            if (inputMode == 1)
            {
                buttons[clearbuttonIndex].OnInteract();
                while (timeHeld < 3) { yield return new WaitForSeconds(0.1f); }
                buttons[clearbuttonIndex].OnInteractEnded();
            }
            for (int i = 1; i < parameters3.Length - 1; i++)
            {
                if (isBreak[i] && inputMode == 2) continue;
                if (parameters3[i][1] == parameters3[i + 1][1])
                {
                    int initialIndex = (parameters3[i][1] - '1') * 5 + (parameters3[i][0] - 'a');
                    int times = parameters3[i][0] - parameters3[i + 1][0];
                    for (int j = 0; j < Math.Abs(times); j++)
                    {
                        if (times > 0)
                            buttons[initialIndex - j - 1].OnInteract();
                        else
                            buttons[initialIndex + j].OnInteract();
                        yield return new WaitForSeconds(0.1f);
                    }
                }
                else if (parameters3[i][0] == parameters3[i + 1][0])
                {
                    int initialIndex = (parameters3[i][1] - '1') + (parameters3[i][0] - 'a') * 7;
                    int times = parameters3[i][1] - parameters3[i + 1][1];
                    for (int j = 0; j < Math.Abs(times); j++)
                    {
                        if (times > 0)
                            buttons[40 + initialIndex - j - 1].OnInteract();
                        else
                            buttons[40 + initialIndex + j].OnInteract();
                        yield return new WaitForSeconds(0.1f);
                    }
                }
                yield return "trycancel Drawing has been halted due to a request to cancel";
            }
            yield break;
        }
        command = command.Replace(" ", String.Empty);
        command = command.ToLower();
        string[] parameters = command.Split(',',';');
        yield return null;
        for (int i = 0; i < parameters.Length; i++)
        {
            if (!Regex.IsMatch(parameters[i], @"^\s*([a-f][1-8]){2}\s*$", RegexOptions.IgnoreCase))
            {
                yield return "sendtochaterror The specified cell pair '" + parameters[i] + "' is invalid!";
                yield break;
            }
            char[] parametersInCharArray = parameters[i].ToCharArray();
            int charDifference = Math.Abs(parametersInCharArray[0] - parametersInCharArray[2]);
            int numberDifference = Math.Abs(parametersInCharArray[1] - parametersInCharArray[3]);
            if (!((charDifference == 1 && numberDifference == 0) || (charDifference == 0 && numberDifference == 1)))
            {
                yield return "sendtochaterror The specified cell pair '" + parameters[i] + "' is not adjacent!";
                yield break;
            }
        }
        for (int i = 0; i < parameters.Length; i++)
        {
            char[] parametersInCharArray = parameters[i].ToCharArray();
            int charDifference = parametersInCharArray[0] - parametersInCharArray[2];
            int numberDifference = parametersInCharArray[1] - parametersInCharArray[3];
            if (Math.Abs(charDifference) == 1 && Math.Abs(numberDifference) == 0)
            {
                int buttonToPress = (parametersInCharArray[1] - '1') * 5 + ((charDifference > 0 ? parametersInCharArray[2] : parametersInCharArray[0]) - 'a');
                buttons[buttonToPress].OnInteract();
            }
            else if (Math.Abs(charDifference) == 0 && Math.Abs(numberDifference) == 1)
            {
                int buttonToPress = 40 + (parametersInCharArray[0] - 'a') * 7 + ((numberDifference > 0 ? parametersInCharArray[3] : parametersInCharArray[1]) - '1');
                buttons[buttonToPress].OnInteract();
            }
            yield return new WaitForSeconds(0.1f);
        }
    }

    IEnumerator TwitchHandleForcedSolve()
    {
        if (horizSelection != "0000000000000000000000000000000000000000" || vertSelection != "000000000000000000000000000000000000000000")
        {
            buttons[clearbuttonIndex].OnInteract();
            while (timeHeld < 3) { yield return true; }
            buttons[clearbuttonIndex].OnInteractEnded();
        }
        bool foundSolution = false;
        bool whileLoopBreakFlag = false;
        int i = 0;
        int j = 0;
        while (!whileLoopBreakFlag)
        {
            bool foundCondition = false;
            if (i % 6 != 5)
            {
                if (solutionH[usedPuzzle][i - i / 6] == '1' && horizSelection.ElementAt(i - i / 6).Equals('0'))
                {
                    foundCondition = true;
                    foundSolution = true;
                    buttons[i - i / 6].OnInteract();
                    yield return new WaitForSeconds(0.1f);
                    i++;
                    j += 8;
                }
            }
            if (i % 6 != 0)
            {
                if (solutionH[usedPuzzle][i - i / 6 - 1] == '1' && horizSelection.ElementAt(i - i / 6 - 1).Equals('0'))
                {
                    foundCondition = true;
                    foundSolution = true;
                    buttons[i - i / 6 - 1].OnInteract();
                    yield return new WaitForSeconds(0.1f);
                    i--;
                    j -= 8;
                }
            }
            if (j % 8 != 7)
            {
                if (solutionV[usedPuzzle][j - j / 8] == '1' && vertSelection.ElementAt(j - j / 8).Equals('0'))
                {
                    foundCondition = true;
                    foundSolution = true;
                    buttons[40 + j - j / 8].OnInteract();
                    yield return new WaitForSeconds(0.1f);
                    j++;
                    i += 6;
                }
            }
            if (j % 8 != 0)
            {
                if (solutionV[usedPuzzle][j - j / 8 - 1] == '1' && vertSelection.ElementAt(j - j / 8 - 1).Equals('0'))
                {
                    foundCondition = true;
                    foundSolution = true;
                    buttons[40 + j - j / 8 - 1].OnInteract();
                    yield return new WaitForSeconds(0.1f);
                    j--;
                    i -= 6;
                }
            }
            if  (!foundCondition)
            {
                if (foundSolution)
                {
                    whileLoopBreakFlag = true;
                }
                else
                {
                    if (j >= 47 || i >= 47)
                    {
                        //The loop fails to meet any condition. Resorting to original forced solver.
                        yield return ProcessTwitchCommand("h " + solutionH[usedPuzzle]);
                        yield return ProcessTwitchCommand("v " + solutionV[usedPuzzle]);
                        break;
                    }
                    if (i % 6 != 5)
                    {
                        i++;
                        j += 8;
                    }
                    else
                    {
                        i++;
                        j -= 39;
                    }
                }
            }
        }
        yield return ProcessTwitchCommand("submit");
    }
}
